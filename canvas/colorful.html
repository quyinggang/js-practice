<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>炫彩小球</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }
      #canvas {
        border: 1px solid #ddd;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
      const canvasElement = document.getElementById('canvas');
      const ctx = canvasElement.getContext('2d');
      let raf = null;
      const circleList = [];
      const getRandomColor = () => {
        const type = '0123456789ABCDEF';
        const len = type.length;
        let color = '#';
        for (let index = 0; index < 6; index++) {
          color += type[Math.ceil(Math.random() * len)];
        }
        return color;
      };

      function Circle(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        // 实现散乱小球
        this.dx = Math.random() * 12 - 7;
        this.dy = Math.random() * 12 - 7;
        circleList.push(this);
      }

      Circle.prototype.render = function () {
        const { x, y, color, radius } = this;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.closePath();
      };
      Circle.prototype.update = function () {
        this.x += this.dx;
        this.y += this.dy;
        this.radius = parseFloat((this.radius - 0.8).toFixed(2));
        if (this.radius <= 0) {
          for (let index = 0, len = circleList.length; index < len; index++) {
            if (circleList[index] === this) {
              circleList.splice(index, 1);
            }
          }
        }
      };

      const renderFrame = () => {
        ctx.clearRect(0, 0, 600, 400);
        circleList.forEach((item) => {
          item.update();
          item.render();
        });
        raf = window.requestAnimationFrame(renderFrame);
      };

      canvasElement.onmouseleave = () => {
        ctx.clearRect(0, 0, 600, 400);
        raf && window.cancelAnimationFrame(raf);
      }
      canvasElement.onmouseover = () => {
        renderFrame();
      }
      canvasElement.onmousemove = (event) => {
        new Circle(event.pageX, event.pageY, 20, getRandomColor());
      };

    </script>
  </body>
</html>
